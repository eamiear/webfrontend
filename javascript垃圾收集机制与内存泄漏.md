# javascript垃圾收集机制与内存泄漏

>摘抄于....忘了

`Javascript`具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。

而在`C`和`C++`之类的语言中，开发人员的一项基本任务就是手动跟踪内存的使用情况，这是造成许多问题的一个根源。在编写`Javascript`程序时，开发人员不用再关心内存使用的问题，所需内存的分配以及无用内存的回收完全实现了自动管理。

这种垃圾回收机制的原理很简单：找出那些不再继续使用的变量，然后释放其中占用的内存。为此，垃圾回收器会按照固定的时间间隔（或代码执行中预设的收集时间），周期性的执行这一操作。

下面我们来分析一下函数中局部变量正常的声明周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈或堆内存上分配相应的空间，以便存储他们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放他们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾回收器必须跟踪哪个变量有用哪个变量没用，对于不有用的变量打上标记，以备将来回收器占用的内存。用于标识无用变量的策略可能会因现实而异，但具体到浏览器中的实现，通常有两个策略。

#####**垃圾回收机制的两种策略**
######**标记清除**

`Javascript`中最常用的垃圾回收方式是标识清除`（mark-and-sweep）`。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，则将其标记为“离开环境”。

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中变量以及被环境中的变量引用的变量标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

大多数浏览器的`Javascript`实现使用的都是标记清除式的垃圾回收策略，只不过垃圾回收器的时间间隔互不相同。

<br>
######**引用计数**

另一个不太常见的垃圾回收策略叫做引用计数`（reference counting）`。引用计数的含义是跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1，当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就可以将其中占用的内存空间回收回来。这样当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

引用计数存在一个严重的问题:循环引用。循环引用指的是对象`A`中包含一个指向对象`B`的引用，而对象`B`中也包含一个指向对象`A`的引用。


```
function () {
    var objectA = new Object();
    var objectB = new Object();

    objectA.someOtherObject = objectB;
    objectB.anotherObject = objectA;
}

```

在这个例子中，`objectA`和`objectB`通过各自的属性相互引用，也就是说，这两个对象的引用次数都是2.在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域。因此这两种相互引用不是个问题。但在采用引用计数策略的实现中，在函数执行完毕后，`objectA`和`objectB`还将继续存在，因此他们的引用次数永远不会是0。假如这个函数被重复调用，就会导致大量的内存得不到回收（函数在调用过程会重新为变量分配内存空间）。

<br>
######**引用计数在IE浏览器中存在的一些问题：**

`IE`中有一部分对象并不是原生`Javascript`对象。例如，其中`BOM`和`DOM`中的对象就是使用`C++`以`COM`（`Component Object Model`，组件对象模型）对象的形式实现的，而`COM`对象的垃圾回收机制采用的就是引用计数策略。因此，即使`IE`的`Javascript`引擎是使用标记清除策略来实现的，但`Javascript`访问的`COM`对象依然是基于引用计数策略的。换句话说，只要`IE`中设计`COM`对象，就会存在循环引用 的问题。
下面的例子，展示了使用`COM`对象导致的循环引用问题：

```

//DOM对象
var element = document.getElementById("some_element");

//javascript原生对象
var myObject = new Object();

//原生对象引用DOM对象
myObject.element = element;

//DOM对象引用原生对象
element.somObject = myObject;
```

例子在一个`DOM`元素（`element`）与一个原生的`javascript`对象之间创建了循环引用。其中，变量`myObject`有一个名为`element`的属性指向`element`对象；而变量`element`也有一个属性`someObject`回指`myObject`。由于存在这个循环引用，即使将例子中的`DOM`从页面中删除，它也永远不会被回收。

为了避免类似这样的循环引用问题，最好是不适用他们的时候手工断开原生`javascript`对象与`DOM`元素之间的链接。例如，可以使用下面的代码消除前面例子创建的循环引用

```
myObject.element = null;
element.somObject = null;
```

将变量设置为`null`，意味着切断变量与它此前引用的值之间的连接。垃圾回收器下次运行时，就会删除这些值并回收他们占用的内存。

######**性能问题**

垃圾回收器都是周期性运行的，而且如果为变量分配的内存数量很客观，那么回收工作量也是相当大的。在这种情况下，确定垃圾回收器的时间间隔是一个非常重要的问题。说到垃圾回收器多长时间运行一次，不禁让人联想到`IE`因此声名狼藉的性能问题。

`IE`的垃圾回收器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素或者64KB的字符串。达到上述任何一个临界值，垃圾回收期就会运行。这种实现的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期一直保持那么多的变量。而这样一来，垃圾回收器就可能不得不频繁的运行。结果，由此引发严重性能问题。IE7重写了其垃圾回收例程。

随着IE7的发布，其`javascript`引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。`IE7`中的各项临界值在初始化时与`IE6`相等。如果例程回收的内存分配量低于15%，则变量 、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界重置会默认值。这一看似简单的调整，极大地提升了IE在运行包含大量`javascript`的页面时的性能。


######**管理内存**

使具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，`javascript`在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最重要的一个问题，就是分配给web浏览器的可使用内存数量通常要比分配给桌面应用程序的少。这样做的目的出要是处于安全方面的考虑，目的是防止运行`javascript`的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行语句数量。

因此，确保占用最少内存可以让页面获得更好的性能，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用(`dereferencing`)。这一做法是用于大多数全局变量和全局对象的属性。局部变量会在他们执行环境时自动被解除引用，如下面这个例子所示：


```
function createPerson (name) {
    var localPerson = new Object();
    localPerson.name = name;
    return localPerson;
};
var gllbalPerson = createPerson("Nicholas");

// 手工解除globalPerson的引用
globalPerson = null;

```

在这个例子中，变量`globalPerson`取得了`createPerson()`函数返回的值。在`createPerson()`函数内部，我们创建了一个对象并将其赋给了局部变量`localPerson`，然后又为该对象添加了一个名为`name`的属性。最后，当调用这个函数时，`localPerson`以函数的形式返回并赋给全局变量`globalPerson`。由于`localPerson`在`createPerson()`函数执行完毕后就离开了其执行环境，因此无需我们显示的去为他解除引用。但是对于全局变量`globalPerson`而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一 行代码的目的。

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，一边垃圾收集器下次运行时将其回收。


######**内存泄漏**

由于`IE`对`JScript`对象和`COM`对象使用不同的垃圾收集例程，因此闭包在IE中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个`HTML`元素，那么就意味着该元素无法被销毁。来看下面的例子：

```
function assignHandler () {
    var element = document.getElementById("someElement");
    element.onclick = function () {
        alert(element.id);
    };
};

```

以上代码创建了一个作为`element`元素时间处理程序的闭包，而这个闭包则有创建了一个循环引用。由于匿名函数保存了一个对`assignHandler()`的活动对象的引用，因此就会导致无法减少`element`的引用数。只要匿名函数存在，`element`的引用数至少也是1，
因此它所占用的内存就永远不会被回收。不过，这个问题可以通过稍微改写一下代码来解决，如下所示：

```
function assignHandler () {
     var element = document.getElementById("someElement");
    var id = element.id;
    
    element.onclick = function () {
        alert(id);
    };
    
    element = null;
};

```

在上面代码中，通过把`element.id`的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏 的问题。必须要记住：闭包会引用包含函数活动的整个活动对象，而其中包含着`element`。即使闭包不直接引用`element`，包含函数的活动对象中也仍 然会保存一个引用。因此，有必要把`element`变量设置为`null`。这样就能够解除对`DOM`对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。
